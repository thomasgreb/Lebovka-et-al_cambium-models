<?xml version="1.0" encoding="UTF-8"?>

<!-- 
  $Rev: c2962c0745f8 $:  Revision of last commit
  $Author: michael $:  Author of last commit
  $Source: auxin_growth.xml $:  Source file
  $Date: 2010/10/14 09:19:03 $:  Date of last commit

  This file is part of the Virtual Leaf.

  The Virtual Leaf is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  The Virtual Leaf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with the Virtual Leaf.  If not, see <http://www.gnu.org/licenses/>.

  Copyright 2010 Roeland Merks.
-->

<leaf name="/Users/roel/VLeafClean_plugin/Snapshot/VLeafMacOSX/auxin_growth.xml" date="Sat Aug 29 18:28:19 2009" simtime="11660">
  <parameter>
    <par name="export_interval" val="1000"/>
    <par name="export_fn_prefix" val="cell."/>
    <par name="arrowcolor" val="white"/>
    <par name="arrowsize" val="10"/>
    <par name="textcolor" val="red"/>
    <par name="cellnumsize" val="1"/>
    <par name="nodenumsize" val="1"/>
    <par name="node_mag" val="1"/>
    <par name="outlinewidth" val="1"/>
    <par name="cell_outline_color" val="forestgreen"/>
    <par name="resize_stride" val="10"/>
    <par name="T" val="1"/>
    <par name="lambda_length" val="100"/>
    <par name="lambda_celllength" val="0"/>
    <par name="target_length" val="60"/>
    <par name="cell_expansion_rate" val="10"/>
    <par name="cell_div_expansion_rate" val="10"/>
    <par name="auxin_dependent_growth" val="true"/>
    <par name="ode_accuracy" val="0.0001"/>
    <par name="mc_stepsize" val="0.4"/>
    <par name="mc_cell_stepsize" val="0.2"/>
    <par name="energy_threshold" val="1000"/>
    <par name="bend_lambda" val="0"/>
    <par name="alignment_lambda" val="0"/>
    <par name="rel_cell_div_threshold" val="2"/>
    <par name="rel_perimeter_stiffness" val="2"/>
    <par name="collapse_node_threshold" val="0.05"/>
    <par name="morphogen_div_threshold" val="0.2"/>
    <par name="morphogen_expansion_threshold" val="0.01"/>
    <par name="copy_wall" val="true"/>
    <par name="source" val="0"/>
    <par name="D">
      <valarray>
        <val v="1e-06"/>
        <val v="0"/>
        <val v="0"/>
        <val v="0"/>
      </valarray>
    </par>
    <par name="initval">
      <valarray>
        <val v="0"/>
        <val v="1"/>
        <val v="0"/>
        <val v="0"/>
      </valarray>
    </par>
    <par name="k1" val="1"/>
    <par name="k2" val="0.3"/>
    <par name="r" val="1"/>
    <par name="kr" val="1"/>
    <par name="km" val="1"/>
    <par name="Pi_tot" val="1"/>
    <par name="transport" val="0.36"/>
    <par name="ka" val="1"/>
    <par name="pin_prod" val="0"/>
    <par name="pin_prod_in_epidermis" val="0"/>
    <par name="pin_breakdown" val="0"/>
    <par name="pin_breakdown_internal" val="0.001"/>
    <par name="aux1prod" val="0.001"/>
    <par name="aux1prodmeso" val="0"/>
    <par name="aux1decay" val="0.001"/>
    <par name="aux1decaymeso" val="0.1"/>
    <par name="aux1transport" val="0.036"/>
    <par name="aux_cons" val="0"/>
    <par name="aux_breakdown" val="0.0001"/>
    <par name="kaux1" val="1"/>
    <par name="kap" val="1"/>
    <par name="leaf_tip_source" val="0.0001"/>
    <par name="sam_efflux" val="0.0001"/>
    <par name="sam_auxin" val="10"/>
    <par name="sam_auxin_breakdown" val="0"/>
    <par name="dt" val="0.1"/>
    <par name="rd_dt" val="10"/>
    <par name="datadir" val="auxin_growth"/>
    <par name="movie" val="true"/>
    <par name="nit" val="100000"/>
    <par name="maxt" val="1e+06"/>
    <par name="storage_stride" val="100"/>
    <par name="xml_storage_stride" val="500"/>
    <par name="rseed" val="-1"/>
    <par name="constituous_expansion_limit" val="16"/>
    <par name="vessel_inh_level" val="1"/>
    <par name="vessel_expansion_rate" val="0.25"/>
    <par name="d" val="0"/>
    <par name="e" val="0"/>
    <par name="f" val="0"/>
    <par name="c" val="0"/>
    <par name="mu" val="0"/>
    <par name="nu" val="0"/>
    <par name="rho0" val="0"/>
    <par name="rho1" val="0"/>
    <par name="c0" val="0"/>
    <par name="gamma" val="0"/>
    <par name="eps" val="0"/>
  </parameter>
  <code name="VirtualLeaf.cpp">#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;cstring&gt;
#include &lt;functional&gt; 
#include &lt;getopt.h&gt;
#include &lt;cerrno&gt;
#include "mesh.h"
#include "parameter.h"
#include "random.h"
#include "pi.h"
#include "cellitem.h"
#include "canvas.h"
#include "cell.h"
#include "output.h"
#include &lt;qwidget.h&gt;
#include &lt;q3process.h&gt;
#include &lt;qapplication.h&gt;
#include &lt;QDesktopWidget&gt;
#include &lt;QGraphicsScene&gt;
#include &lt;QMessageBox&gt;
//Added by qt3to4:
#include &lt;QMouseEvent&gt;

#include &lt;unistd.h&gt;
#include &lt;q3textstream.h&gt; 


#ifdef HAVE_QWT
#include "data_plot.h"
#endif
#include &lt;QPalette&gt;
#include &lt;QBrush&gt;
#include &lt;QToolTip&gt;
#include "simplugin.h"
#include "testplugin.h"

/* #define _xstr_(s) _str_(s)
#define _str_(s) #s
#include _xstr_(REACTIONS_HEADER)
*/
extern Parameter par;

MainBase *main_window = 0;
double auxin_account = 0.;



TestPlugin *plugin = new TestPlugin();

#ifdef XFIGGRAPHICS
#define TIMESTEP double Graphics::TimeStep(void)
#endif

class PrintNode {
public:
  void operator() (const Node &amp;n) const 
  {
    cerr &lt;&lt; n.Index() &lt;&lt; ": " &lt;&lt; n &lt;&lt;  endl;
  }
};


class EdgeSource {
	
public:
  void operator() (Cell &amp;c) {
		
    if (c.AtBoundaryP()) {
      cerr &lt;&lt; "Cell " &lt;&lt; c.Index() &lt;&lt; " is a source cell.\n";
      c.SetSource(0,par.source);
    } else {
      cerr &lt;&lt; "Cell " &lt;&lt; c.Index() &lt;&lt; " is _not_ a source cell.\n";
    }
  }
	
};



class CellInfo {
public:
  void operator() (Cell &amp;c,std::ostream &amp;os) const {
    os &lt;&lt; "Cell " &lt;&lt; c.index &lt;&lt; " says: " &lt;&lt; endl;
    os &lt;&lt; "c.nodes.size() = " &lt;&lt; c.nodes.size() &lt;&lt; endl;
    for (list&lt;Node *&gt;::iterator i=c.nodes.begin();
	 i!=c.nodes.end();
	 i++) {
      cerr &lt;&lt; (*i)-&gt;Index() &lt;&lt; " ";
    }
    cerr &lt;&lt; endl;
  }
};

double PINSum(Cell &amp;c) {
	
	return c.Chemical(1) + c.SumTransporters(1);// + c.ReduceCellAndWalls&lt;double&gt;( complex_PijAj );
	
}


class DrawCell {
public:
  void operator() (Cell &amp;c,QGraphicsScene &amp;canvas, MainBase &amp;m) const {
    if (m.ShowBorderCellsP() || c.Boundary()==Cell::None) {
      if (!m.ShowBoundaryOnlyP() &amp;&amp; !m.HideCellsP()) 
	if (m.ShowToolTipsP()) {
	  QString info_string=QString("Cell %1, chemicals: ( %2, %3, %4, %5, %6)\n %7 of PIN1 at walls.\n Area is %8\n PIN sum is %9\n Circumference is %10\n Boundary type is %11").arg(c.Index()).arg(c.Chemical(0)).arg(c.Chemical(1)).arg(c.Chemical(2)).arg(c.Chemical(3)).arg(c.Chemical(4)).arg(c.SumTransporters(1)).arg(c.Area()).arg(PINSum(c)).arg(c.Circumference()).arg(c.BoundaryStr());
					
	  info_string += "\n" + c.printednodelist();
					
	  c.Draw(&amp;canvas, info_string);
	} else {
	  c.Draw(&amp;canvas);
	}
      if (m.ShowCentersP())
	c.DrawCenter(&amp;canvas);
    if (m.ShowFluxesP())
	c.DrawFluxes(&amp;canvas, par.arrowsize);
			
       }
 
  }
	
};

Mesh mesh;
bool batch=false;


void MainBase::Plot(int resize_stride) {
	
  clear();
    
	
  static int count=0;
  if (resize_stride) {
    if ( !((++count)%resize_stride) ) {
      FitLeafToCanvas();
    }
  }
  mesh.LoopCells(DrawCell(),canvas,*this);
	
  if (ShowNodeNumbersP()) 
    mesh.LoopNodes( bind2nd (mem_fun_ref ( &amp;Node::DrawIndex), &amp;canvas ) ) ;
  if (ShowCellNumbersP()) 
    mesh.LoopCells( bind2nd (mem_fun_ref ( &amp;Cell::DrawIndex), &amp;canvas ) ) ;
	
  if (ShowCellAxesP()) 
    mesh.LoopCells( bind2nd (mem_fun_ref ( &amp;Cell::DrawAxis), &amp;canvas ) );
	
  if (ShowCellStrainP()) 
    mesh.LoopCells( bind2nd (mem_fun_ref ( &amp;Cell::DrawStrain), &amp;canvas ) );
	
  if (ShowWallsP())
  
    mesh.LoopWalls( bind2nd( mem_fun_ref( &amp;Wall::Draw ), &amp;canvas ) );
	
	if (ShowApoplastsP()) 
		mesh.LoopWalls( bind2nd( mem_fun_ref( &amp;Wall::DrawApoplast ), &amp;canvas ) );
 
	if (ShowMeshP()) 
    mesh.DrawNodes(&amp;canvas);
	
  if (ShowBoundaryOnlyP()) 
    mesh.DrawBoundary(&amp;canvas);

  
	if ( ( batch || MovieFramesP() )) {
		
		static int frame = 0;
		// frame numbers are sequential for the most frequently written file type.
		// for the less frequently written file type they match the other type
		if (!(count%par.storage_stride) )  {
		
			stringstream fname;
			fname &lt;&lt; par.datadir &lt;&lt; "/leaf.";
			fname.fill('0');
			fname.width(6);
	
			/* 
			 fname &lt;&lt; frame &lt;&lt; ".pdf";
			if (par.storage_stride &lt;= par.xml_storage_stride) {
				frame++;
			}
			
			// Write high-res JPG snapshot every plot step
			Save(fname.str().c_str(), "PDF");
			*/
			
			fname &lt;&lt; frame &lt;&lt; ".jpg";
			if (par.storage_stride &lt;= par.xml_storage_stride) {
				frame++;
			}
			
			// Write high-res JPG snapshot every plot step
			Save(fname.str().c_str(), "JPEG",1024,768);
			
		}
	
		if (!(count%par.xml_storage_stride)) {
			stringstream fname;
			fname &lt;&lt; par.datadir &lt;&lt; "/leaf.";
			fname.fill('0');
			fname.width(6);
			fname &lt;&lt; frame &lt;&lt; ".xml";
	
			if (par.xml_storage_stride &lt; par.storage_stride) {
				frame++;
			}
			// Write XML file every ten plot steps
			mesh.XMLSave(fname.str().c_str(), XMLSettingsTree());
		}
		
	}
}


void Cell::Flux(double *flux, double *D)  {
	

  // loop over cell edges
	
  for (int c=0;c&lt;Cell::nchem;c++) flux[c]=0.;
	
  for (list&lt;Wall *&gt;::iterator i=walls.begin();
       i!=walls.end();
       i++) {
		
		
    // leaf cannot take up chemicals from environment ("no flux boundary")
    if ((*i)-&gt;c2-&gt;BoundaryPolP()) continue;
		
  	
    // flux depends on edge length and concentration difference
    for (int c=0;c&lt;Cell::nchem;c++) {
      double phi = (*i)-&gt;length * ( D[c] ) * ( (*i)-&gt;c2-&gt;chem[c] - chem[c] );
			
      if ((*i)-&gt;c1!=this) {
	cerr &lt;&lt; "Warning, bad cells boundary: " &lt;&lt; (*i)-&gt;c1-&gt;index &lt;&lt; ", " &lt;&lt; index &lt;&lt; endl;
      }
			
      flux[c] += phi;
    }    
  }
	
}

INIT {
	
	if (leaffile) { 
    xmlNode *settings;
    mesh.XMLRead(leaffile, &amp;settings);
    main_window-&gt;XMLReadSettings(settings);
    xmlFree(settings);
    main_window-&gt;UserMessage(QString("Ready. Time is %1").arg(mesh.getTimeHours().c_str()));
		
  } else {
		
	  Cell &amp;circle=mesh.CircularCell(0,0,10,10);
    		
    circle.SetTargetArea(circle.CalcArea());
	  mesh.SetBaseArea();
	// clean up chemicals 
	  for (int c=0; c&lt;Cell::NChem(); c++) {
		  circle.SetChemical(c, 0.);
      }
  }
}

TIMESTEP {
	
  static int i=0;
  static int t=0;
  static int ncells;
	
  if (!batch) {
    UserMessage(QString("Time: %1").arg(mesh.getTimeHours().c_str()),0);
  }
			 
  ncells=mesh.NCells();
		
				
  double dh;
  		
  if(DynamicCellsP()) {
    dh = mesh.DisplaceNodes();
			
    // Only allow for node insertion, cell division and cell growth
    // if the system has equillibrized
    // i.e. cell wall tension equillibrization is much faster
    // than biological processes, including division, cell wall yielding
    // and cell expansion
    mesh.InsertNodes(); // (this amounts to cell wall yielding)
			
    if ( (-dh) &lt; par.energy_threshold) {
				
      mesh.IncreaseCellCapacityIfNecessary();
		mesh.LoopCurrentCells(&amp;TestPlugin::CellHouseKeeping); // this includes cell division
				
      // Reaction diffusion	
		/*CelltoCellTransport *transport_f = &amp;TestPlugin::CelltoCellTransport;
      CellReaction *cellreaction_f = new plugin-&gt;CellDynamics();
      WallReaction *wall_f = new WallDynamics();*/
				
      mesh.ReactDiffuse(plugin, par.rd_dt);
		
				
      t++;
				
      Plot(par.resize_stride);
		
		/*QVector&lt; QPair&lt;double, int&gt; &gt; angles=mesh.VertexAnglesValues();
		QString afname=QString("Angles/anglesvalues%1.dat").arg(t,6,10,QChar('0'));
		ofstream af(afname.toStdString().c_str());
		*/
		
		/*for (QVector&lt; QPair&lt;qreal, int&gt; &gt;::const_iterator v=angles.begin();
			 v!=angles.end();
			 v++) {
			af &lt;&lt; v-&gt;first &lt;&lt; " " &lt;&lt; v-&gt;second &lt;&lt; endl;
			}
			*/
			}
		
			} else {
			
  /*  TransportFunction *transport_f = new CelltoCellTransport();
    CellReaction *cellreaction_f = new CellDynamics();
    WallReaction *wall_f = new WallDynamics();
			
    mesh.ReactDiffuse_New(transport_f, cellreaction_f, wall_f, par.rd_dt);*/
				mesh.ReactDiffuse(plugin, par.rd_dt);
		
    Plot(par.resize_stride);
			
  }
	
	

		
		
  i++;
  return mesh.getTime();
		
}
		
		
				
/* Called if a cell is clicked */
void Cell::OnClick(QMouseEvent *e) {
					
}
				
				

void Wall::OnWallInsert(void) {
				  

}

				
				
				
int main(int argc,char **argv) {
					
  try {
						

    int c;

						
    char *leaffile=0;

						
    while (1) {
							
      //int this_option_optind = optind ? optind : 1;
      int option_index = 0;
      static struct option long_options[] = {
	{"batch", 0, 0, 0},
	{"leaffile", 2, 0, 0}
      };
		
      // short option 'p' creates trouble for non-commandline usage on MacOSX. Option -p changed to -P (capital)
      static char *short_options = "bl";
      c = getopt_long (argc, argv, "bl:",
		       long_options, &amp;option_index);
      if (c == -1)
	break;
		
		
      if (c==0) {
	printf ("option %s", long_options[option_index].name);
	if (optarg)
	  printf (" with arg %s", optarg);
	printf ("\n");
			
	c = short_options[option_index];
      }
		
      switch (c) {
      case 'b':
	cerr &lt;&lt; "Running in batch mode\n";
	batch=true;
	break;
				
      case 'l':
	leaffile=strdup(optarg);
	if (!leaffile) {
	  throw("Out of memory");
	}
	printf("Reading leaf state file '%s'\n", leaffile);
	break;
				
      case '?':
	break;
				
      default:
	printf ("?? getopt returned character code 0%o ??\n", c);
      }
    }
	  
	  
    if (optind &lt; argc) {
      printf ("non-option ARGV-elements: ");
      while (optind &lt; argc)
	printf ("%s ", argv[optind++]);
      printf ("\n");
    }
	  
	  MakeDir("Angles");
    bool useGUI = !batch;
    QApplication app(argc,argv,useGUI);
						

    
    QPalette tooltippalette = QToolTip::palette();
    QColor transparentcolor = QColor(tooltippalette.brush(QPalette::Window).color());

    tooltippalette.setBrush (QPalette::Window, QBrush (transparentcolor) );
    QToolTip::setPalette( tooltippalette );

    QGraphicsScene canvas(0,0,8000,6000);

    if (useGUI) {
         main_window=new Main(canvas, mesh);
      if ( QApplication::desktop()-&gt;width() &gt; ((Main *)main_window)-&gt;width() + 10
	   &amp;&amp; QApplication::desktop()-&gt;height() &gt; ((Main *)main_window)-&gt;height() +30 ) {

	((Main *)main_window)-&gt;show();
	((Main *)main_window)-&gt;resize( ((Main *)main_window)-&gt;sizeHint());
    } else {
        ((Main *)main_window)-&gt;showMaximized();
    }
  } else {
        main_window=new MainBase(canvas, mesh);

 }

    
	  
    canvas.setSceneRect(QRectF());
    if (!batch) {
      QObject::connect( qApp, SIGNAL(lastWindowClosed()), qApp, SLOT(quit()) );
    }

						
 		
    main_window-&gt;Init(leaffile);
	  
    Cell::SetMagnification(10);
    Cell::setOffset(0,0);
						
    main_window-&gt;FitLeafToCanvas();
						
				
						
    main_window-&gt;Plot();

						

    if (batch) {
      double t=0.;
      do {
	t = main_window-&gt;TimeStep();
      } while (t &lt; par.maxt);
							
    } else
      return app.exec();
	  
						
  } catch (const char *message) {
    if (batch) { 
      cerr &lt;&lt; "Exception caught:" &lt;&lt; endl;
      cerr &lt;&lt; message &lt;&lt; endl;
      abort();
    } else {
      QString qmess=QString("Exception caught: %1").arg(message);
      QMessageBox::critical(0, "Critical Error", qmess);
      abort();
    }
  } catch (ios_base::failure) {
    stringstream error_message;
    error_message &lt;&lt; "I/O failure: " &lt;&lt; strerror(errno);
    if (batch) {
      cerr &lt;&lt; error_message.str() &lt;&lt;endl;
      abort();
    } else {
      QString qmess(error_message.str().c_str());
      QMessageBox::critical(0, "I/O Error", qmess );
      abort();
    }
  }
					
}
</code>
  <code name="reactions_pce_growth.h">

// Executed after the cellular mechanics steps have equillibrized
class CellHouseKeeping {
public:
	void operator() (Cell &amp;c) const {
		
		c.EnlargeTargetArea(par.cell_expansion_rate);
		
		if (c.Area() &gt; par.rel_cell_div_threshold * c.BaseArea() ) {
			c.Divide();
		}
	}
};

// The number of chemical species in the cels
const int Cell::nchem = 0;

// Differential equations describing transport of chemicals from cell to cell
class CelltoCellTransport : public TransportFunction {

 public:
	virtual void operator()(Wall *w, double *dchem_c1, double *dchem_c2) {}
    
 };

// Differential equations describing chemical reactions taking place at or near the cell walls
// (e.g. PIN accumulation)
class WallDynamics : public WallReaction {
 public:
	virtual void operator()(Wall *w, double *dw1, double *dw2) {}; 
	
};


// Differential equations describing chemical reactions inside the cells
class CellDynamics : public CellReaction {
 public:
	virtual void operator()(Cell *c, double *dchem) {
	
	};
	
};

// Rules for cell coloring
void Cell::SetColor(QColor &amp;color) { }

// To be executed after cell division
void Cell::OnDivide(ParentInfo &amp;parent_info, Cell &amp;daughter) {}

</code>
  <nodes n="22" target_length="3.09017">
    <node x="22.9634" y="-2.37264" fixed="false" boundary="true" sam="false"/>
    <node x="14.6882" y="17.9118" fixed="false" boundary="true" sam="false"/>
    <node x="1.57936" y="25.1246" fixed="false" boundary="true" sam="false"/>
    <node x="-9.0893" y="22.8165" fixed="false" boundary="true" sam="false"/>
    <node x="-19.7055" y="16.962" fixed="false" boundary="true" sam="false"/>
    <node x="-22.6839" y="5.00143" fixed="false" boundary="true" sam="false"/>
    <node x="-14.7271" y="-15.2131" fixed="false" boundary="true" sam="false"/>
    <node x="-6.78413" y="-23.4002" fixed="false" boundary="true" sam="false"/>
    <node x="3.60766" y="-25.1355" fixed="false" boundary="true" sam="false"/>
    <node x="21.3032" y="-13.6899" fixed="false" boundary="true" sam="false"/>
    <node x="17.4704" y="7.41573" fixed="false" boundary="true" sam="false"/>
    <node x="-17.5799" y="-5.20265" fixed="false" boundary="true" sam="false"/>
    <node x="9.86837" y="4.69636" fixed="false" boundary="false" sam="false"/>
    <node x="-9.28449" y="-3.92969" fixed="false" boundary="false" sam="false"/>
    <node x="12.5597" y="-20.5161" fixed="false" boundary="true" sam="false"/>
    <node x="-1.62187" y="-3.10623" fixed="false" boundary="false" sam="false"/>
    <node x="7.55765" y="-14.4922" fixed="false" boundary="false" sam="false"/>
    <node x="2.97596" y="-8.80653" fixed="false" boundary="false" sam="false"/>
    <node x="1.95125" y="3.2756" fixed="false" boundary="false" sam="false"/>
    <node x="-6.54614" y="15.4702" fixed="false" boundary="false" sam="false"/>
    <node x="-2.72983" y="8.96705" fixed="false" boundary="false" sam="false"/>
    <node x="9.33552" y="23.0046" fixed="false" boundary="true" sam="false"/>
  </nodes>
  <cells n="4" offsetx="0" offsety="0" magnification="10" base_area="293.893" nchem="2">
    <cell index="0" area="405.845" target_area="548.609" target_length="60" lambda_celllength="0" stiffness="0" fixed="false" pin_fixed="false" at_boundary="true" dead="false" source="false" boundary="None" div_counter="2" cell_type="0">
      <node n="13"/>
      <node n="11"/>
      <node n="6"/>
      <node n="7"/>
      <node n="8"/>
      <node n="14"/>
      <node n="16"/>
      <node n="17"/>
      <node n="15"/>
      <wall w="6"/>
      <wall w="0"/>
      <wall w="1"/>
      <chem n="2">
        <val v="0.251808"/>
        <val v="0.481961"/>
      </chem>
    </cell>
    <cell index="1" area="385.557" target_area="547.081" target_length="60" lambda_celllength="0" stiffness="0" fixed="false" pin_fixed="false" at_boundary="true" dead="false" source="false" boundary="None" div_counter="2" cell_type="0">
      <node n="12"/>
      <node n="10"/>
      <node n="1"/>
      <node n="21"/>
      <node n="2"/>
      <node n="3"/>
      <node n="19"/>
      <node n="20"/>
      <node n="18"/>
      <wall w="3"/>
      <wall w="4"/>
      <wall w="5"/>
      <chem n="2">
        <val v="0.250735"/>
        <val v="0.481961"/>
      </chem>
    </cell>
    <cell index="2" area="422.94" target_area="565.987" target_length="60" lambda_celllength="0" stiffness="0" fixed="false" pin_fixed="false" at_boundary="true" dead="false" source="false" boundary="None" div_counter="2" cell_type="0">
      <node n="9"/>
      <node n="0"/>
      <node n="10"/>
      <node n="12"/>
      <node n="18"/>
      <node n="15"/>
      <node n="17"/>
      <node n="16"/>
      <node n="14"/>
      <wall w="1"/>
      <wall w="2"/>
      <wall w="8"/>
      <wall w="4"/>
      <chem n="2">
        <val v="0.307348"/>
        <val v="0.481245"/>
      </chem>
    </cell>
    <cell index="3" area="432.871" target_area="573.317" target_length="60" lambda_celllength="0" stiffness="0" fixed="false" pin_fixed="false" at_boundary="true" dead="false" source="false" boundary="None" div_counter="2" cell_type="0">
      <node n="4"/>
      <node n="5"/>
      <node n="11"/>
      <node n="13"/>
      <node n="15"/>
      <node n="18"/>
      <node n="20"/>
      <node n="19"/>
      <node n="3"/>
      <wall w="5"/>
      <wall w="6"/>
      <wall w="7"/>
      <wall w="8"/>
      <chem n="2">
        <val v="0.321108"/>
        <val v="0.481222"/>
      </chem>
    </cell>
    <boundary_polygon index="-1" area="1647.21" target_area="1" target_length="60" lambda_celllength="0" stiffness="0" fixed="false" pin_fixed="false" at_boundary="false" dead="false" source="false" boundary="None" div_counter="0" cell_type="0">
      <node n="0"/>
      <node n="10"/>
      <node n="1"/>
      <node n="21"/>
      <node n="2"/>
      <node n="3"/>
      <node n="4"/>
      <node n="5"/>
      <node n="11"/>
      <node n="6"/>
      <node n="7"/>
      <node n="8"/>
      <node n="14"/>
      <node n="9"/>
      <wall w="2"/>
      <wall w="7"/>
      <wall w="0"/>
      <wall w="3"/>
      <chem n="2">
        <val v="0"/>
        <val v="0"/>
      </chem>
    </boundary_polygon>
  </cells>
  <walls n="9">
    <wall index="0" c1="0" c2="-1" n1="11" n2="14" length="42.4253" viz_flux="0" wall_type="aux_source">
      <transporters1>
        <val v="0"/>
        <val v="0"/>
      </transporters1>
      <transporters2>
        <val v="0"/>
        <val v="0"/>
      </transporters2>
      <apoplast>
        <val v="0"/>
        <val v="0"/>
      </apoplast>
    </wall>
    <wall index="1" c1="0" c2="2" n1="14" n2="15" length="22.4554" viz_flux="0" wall_type="normal">
      <transporters1>
        <val v="0"/>
        <val v="0.254701"/>
      </transporters1>
      <transporters2>
        <val v="0"/>
        <val v="0.21777"/>
      </transporters2>
      <apoplast>
        <val v="0"/>
        <val v="0.21777"/>
      </apoplast>
    </wall>
    <wall index="2" c1="2" c2="-1" n1="14" n2="10" length="33.7553" viz_flux="0" wall_type="aux_source">
      <transporters1>
        <val v="0"/>
        <val v="0"/>
      </transporters1>
      <transporters2>
        <val v="0"/>
        <val v="0"/>
      </transporters2>
      <apoplast>
        <val v="0"/>
        <val v="0"/>
      </apoplast>
    </wall>
    <wall index="3" c1="1" c2="-1" n1="10" n2="3" length="37.203" viz_flux="0" wall_type="aux_source">
      <transporters1>
        <val v="0"/>
        <val v="0"/>
      </transporters1>
      <transporters2>
        <val v="0"/>
        <val v="0"/>
      </transporters2>
      <apoplast>
        <val v="0"/>
        <val v="0"/>
      </apoplast>
    </wall>
    <wall index="4" c1="2" c2="1" n1="10" n2="18" length="16.1174" viz_flux="0" wall_type="normal">
      <transporters1>
        <val v="0"/>
        <val v="0.217027"/>
      </transporters1>
      <transporters2>
        <val v="0"/>
        <val v="0.254701"/>
      </transporters2>
      <apoplast>
        <val v="0"/>
        <val v="0.254701"/>
      </apoplast>
    </wall>
    <wall index="5" c1="1" c2="3" n1="3" n2="18" length="22.6835" viz_flux="0" wall_type="normal">
      <transporters1>
        <val v="0"/>
        <val v="0.263338"/>
      </transporters1>
      <transporters2>
        <val v="0"/>
        <val v="0.217021"/>
      </transporters2>
      <apoplast>
        <val v="0"/>
        <val v="0.217021"/>
      </apoplast>
    </wall>
    <wall index="6" c1="0" c2="3" n1="15" n2="11" length="16.0993" viz_flux="0" wall_type="normal">
      <transporters1>
        <val v="0"/>
        <val v="0.263338"/>
      </transporters1>
      <transporters2>
        <val v="0"/>
        <val v="0.217763"/>
      </transporters2>
      <apoplast>
        <val v="0"/>
        <val v="0.217763"/>
      </apoplast>
    </wall>
    <wall index="7" c1="3" c2="-1" n1="3" n2="11" length="35.8587" viz_flux="0" wall_type="aux_source">
      <transporters1>
        <val v="0"/>
        <val v="0"/>
      </transporters1>
      <transporters2>
        <val v="0"/>
        <val v="0"/>
      </transporters2>
      <apoplast>
        <val v="0"/>
        <val v="0"/>
      </apoplast>
    </wall>
    <wall index="8" c1="2" c2="3" n1="18" n2="15" length="7.31402" viz_flux="0" wall_type="normal">
      <transporters1>
        <val v="0"/>
        <val v="0.263073"/>
      </transporters1>
      <transporters2>
        <val v="0"/>
        <val v="0.254437"/>
      </transporters2>
      <apoplast>
        <val v="0"/>
        <val v="0.254437"/>
      </apoplast>
    </wall>
  </walls>
  <nodesets n="0"/>
  <settings>
    <setting name="show_cell_centers" val="false"/>
    <setting name="show_nodes" val="false"/>
    <setting name="show_node_numbers" val="false"/>
    <setting name="show_cell_numbers" val="false"/>
    <setting name="show_border_cells" val="false"/>
    <setting name="show_cell_axes" val="false"/>
    <setting name="show_cell_strain" val="false"/>
    <setting name="show_fluxes" val="true"/>
    <setting name="show_walls" val="true"/>
    <setting name="show_apoplasts" val="false"/>
    <setting name="save_movie_frames" val="true"/>
    <setting name="show_only_leaf_boundary" val="false"/>
    <setting name="cell_growth" val="true"/>
    <setting name="hide_cells" val="false"/>
  </settings>
</leaf>
